/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
let cnt = 0;
function combine(n, k) {
    const res = [];
    const path = [];

    function backtrack(start) {
        cnt++;
        // ⭐ 收敛条件
        // if (path.length === k) {
            res.push([...path]);
            // return;
        // }

        // ⭐ 前序剪枝（重点）
        // 还需要的数量
        const need = k - path.length;//n - i + 1 ≥ need
        
        // 👉 控制递归展开
        /**
         *  循环就像一个 “候选清单”，给 1 列出了所有可能的搭档（2、3、4）。
            递归就像一个 “执行者”，拿着清单逐个核对：
            先拿起 2，和 1 绑定，检查是否满足 k=2（满足），记录结果；
            放下 2，再拿起 3，和 1 绑定，检查满足，记录结果；
            放下 3，再拿起 4，和 1 绑定，检查满足，记录结果；
            所有搭档核对完毕，回到初始状态。
         */

        // 👉 前序剪枝
        /**
         *  循环是为了 每个数值都能放在 头把交椅
         *  递归是为了 把每把交椅坐实
         *  回溯是为了 交出头把交椅，让循环继续
         * 
         * 如果不剪枝 ，就能看到很多无效的循环和 递归
         */
        for (let i = start; i <= n; i++) {
            path.push(i);
            console.log('前',i,   '---', ...path);//'---', n - need + 1,

            backtrack(i + 1);//在路径上，直接去重了
            console.log('后',i,  '---', ...path);
            path.pop(); // 回溯
        }
        //start跟递归的深度有关，i才是路径的核心
    }

    backtrack(1);
    res.forEach((item) => {
        console.log(item);
    });
    return res;
}


console.log(combine(5, 3), cnt);

/**
你觉得 “start=1 但 path 里是 5” 很奇怪，这是因为你潜意识里把 start 和 path 的含义绑定在了一起，但实际上两者没有直接关联，是完全独立的两个概念，我们先戳破这个核心误区，再逐步解释清楚：
一、核心误区：start 和 path 毫无直接关联，各自有独立的使命
很多人会误以为 “start 是当前 path 的开头数字”，这是导致困惑的根源。实际上，两者的含义和作用完全割裂：
变量	核心含义（独立使命）	是否固定	举例（对应最后一条日志）
start	当前递归层的数字选取「起始位置」（仅约束当前层循环的 i 从哪开始）	固定（递归层内）	第一层递归 start=1（初始调用决定），全程不变
path	当前已经选取的数字「组合路径」（记录的是实际选中的结果）	动态变化	第一层循环 i=5 时，path=[5]（选中了 5，和 start 无关）
简单说：start 管 “当前层循环从哪个数字开始选”，path 管 “已经选了哪些数字”，两者各司其职，没有必然的对应关系。
二、为什么第一层递归 start=1，但 path 能是 [5]？
我们结合「第一层递归的循环逻辑」来拆解，核心是：start=1 只是约束第一层循环的 i 从 1 开始遍历，而 path 是由循环变量 i 的取值决定的，不是由 start 决定的。
1. 第一层递归的循环约束：start=1 只决定 i 从 1 开始
第一层递归的循环是：
javascript
运行
// start=1（固定），n=5，无剪枝
for (let i = start; i <= n; i++) { // 等价于 for (let i=1; i<=5; i++)
    path.push(i); // path 的值由 i 决定，不是由 start 决定
    // ... 日志 + 递归
    path.pop();
}
start=1 的作用仅仅是：让第一层循环的 i 从 1 开始遍历（依次取 1、2、3、4、5），它不限制 i 能取到多大，也不限制 path 里能存什么。
当 i=5 时（循环的最后一个轮次），执行 path.push(5)，path 自然就变成了 [5]—— 这是 i=5 导致的，和 start=1 没有任何冲突。
2. 通俗类比：帮你理解 “start 是起始线，path 是选中的目标”
我们用 “选数字” 做一个生活化类比，更易理解：
把第一层递归的循环想象成 “从第 1 号货架开始选商品”（start=1 对应 “1 号货架是起始线”）。
货架依次是 1 号、2 号、3 号、4 号、5 号（对应 i=1 到 i=5）。
你可以从 1 号货架开始，依次选 1 号货架的商品（i=1，path=[1]）、2 号货架的商品（i=2，path=[2]）…… 直到 5 号货架的商品（i=5，path=[5]）。
这里的 “1 号货架（start=1）” 只是告诉你 “从哪开始选”，不代表你只能选 1 号货架的商品 —— 你可以选起始线之后的任意货架商品，对应 path 可以是 [1]、[2]...[5]，这完全合理。
三、再回头看最后一条日志：后 1 --- 5 就完全合理了
我们再整合两个关键点，重新梳理这条日志，你会发现它一点都不奇怪：
后 1：因为这条日志属于第一层递归，而第一层递归的 start 是初始调用 backtrack(1) 决定的，全程固定为 1，和 i=5、path=[5] 无关。
--- 5：因为这是第一层循环 i=5 的轮次，path.push(5) 后路径是 [5]，递归返回后还没执行 path.pop()，所以 path 依然是 [5]。
两者结合：就形成了 后 1 --- 5——start=1 对应递归层的起始位置，path=[5] 对应选中的数字，两者独立存在，毫无冲突。
四、补充验证：其他类似日志也能佐证这个逻辑
其实日志中还有很多类似的情况，都能证明 start 和 path 无关，比如：
日志 前 1 --- 2：start=1（第一层递归），path=[2]（i=2 导致的）
日志 前 1 --- 3：start=1（第一层递归），path=[3]（i=3 导致的）
这些日志和 后 1 --- 5 是同一个逻辑，只是 i 的取值不同而已，它们都能说明：start 固定是 1（第一层递归），path 随 i 动态变化。
总结
核心结论：start 和 path 无直接关联，是独立概念，这是消除困惑的关键。
start=1 的含义：第一层递归的循环起始位置（约束 i 从 1 开始遍历），递归层内固定不变。
path=[5] 的含义：第一层循环 i=5 时，执行 path.push(5) 后的结果，由 i 的取值决定。
日志 后 1 --- 5：是第一层递归（start=1）、i=5 轮次（path=[5]）的回溯日志，两者独立存在，完全合理。
 */