## 位运算种类
### & 位与
逻辑规则：两位都为 1 时结果为 1，否则为 0
#### 基础性质	
1. 任何数 & 0 = 0；
2. 任何数 & 自身 = 自身；
3. 任何数 & 1 ：可提取最低位（1 = 奇数，0 = 偶数）
4. 任何位 & 1：该位不变，掩码操作
5. 任何位 & 0: 该位置为0
#### 常见技巧
1. 判断奇偶（最基础用法）：
```js
function isOdd(n) {
    return (n & 1) === 1; // 1=奇数，0=偶数
}
console.log(isOdd(7)); // true，7是奇数
console.log(isOdd(8)); // false，8是偶数
```
2. 消除二进制最右边的 1（n & (n-1)）：
用途：统计二进制中 1 的个数（汉明重量）、判断是否为 2 的幂（n & (n-1) === 0 则是 2 的幂）。

```js
// 统计1的个数（高效版）
function countOne(n) {
    let count = 0;
    while(n) {
        n = n & (n-1); // 消除最右边的1
        count++;
    }
    return count;
}
console.log(countOne(11)); // 3（1011有3个1）

//类似这样的数 10000***
function is2pow(n){
    return n & (n-1) === 0;
}
```
3. 提取 / 保留指定位（掩码操作）：
比如保留数字的最低 4 位，只需和0b1111（十进制 15）做与运算：

```js
let n = 0b10110101; // 十进制181
let mask = 0b1111;  // 掩码：仅保留最低4位
console.log((n & mask).toString(2)); // 0b101（提取最低4位）
```

### | 位或
逻辑规则	两位有一个为 1 则结果为 1，否则为 0			
#### 基础性质	
1. 任何数 | 0 = 自身；
2. 任何数 | 自身 = 自身；（和&操作一样）
3. 任何数 | 1  ：可将最低位置 1
4. 任何位 | 1，将该位置为1
5. 任何位 | 0，该位不变
#### 常见技巧
1. 指定位置1
```js
let n = 0b101; // 5
let mask = 0b1000; // 第3位为1
console.log((n | mask).toString(2)); // 0b1101（第3位被置1，结果13）
```
2.  合并二进制位信息：
比如将两个 4 位的数合并为 8 位：
```js
let high = 0b1010; // 高4位
let low = 0b0101;  // 低4位
let full = (high << 4) | low; // 左移4位腾出空间，再合并
console.log(full..toString(2)); // 0b10100101
```



### ^ 位异或
逻辑规则	两位不同为 1，相同为 0（“同 0 异 1”）
#### 基础性质	
1. 任何数 ^ 0 = 自身；
2. 任何数 ^ 自身 = 0；
3. 任何位 ^ 0 : 不变
4. 任何位 ^ 1 : 该位翻转
5. 满足交换律 / 结合律；
6. 可逆性：a^b^b = a

#### 常见技巧
1. 翻转指定位（和 1 异或翻转，和 0 异或不变）：
```js
let n = 0b101; // 5
let mask = 0b111; // 翻转最低3位
console.log(bin(n ^ mask)); // 0b010（101翻转为010）
```
2. 简单加密 / 解密（同一密钥可逆）
```js
function xorCrypt(s, key) {
    return s.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ key)).join('');
}
let origin = "hello";
let key = 123;
let crypted = xorCrypt(origin, key);
let decrypted = xorCrypt(crypted, key);
console.log(decrypted); // hello（解密还原）
```

### ~ 位取反
逻辑规则	每一位取反（0→1，1→0），JS/Python 中是补码形式：~n = -n -1
### 基础性质	
1. ~0 = -1（二进制全 1）；
2. ~n + 1 = -n（快速求相反数）；

#### 常见技巧
1.  快速求相反数：
```js
console.log(~5 + 1); // -5
console.log(~-8 + 1); // 8
```

### << 左移
操作规则	所有位左移 n 位，右边补 0
#### 基础性质	
1. 正数左移：n << k = n × 2^k（无溢出时）；
2. 左移不改变符号位（溢出会导致符号变化）
#### 常见技巧
1. 为新位腾位置（颠倒二进制位）：
```js
// 颠倒32位二进制位的核心步骤
let result = 0, n = 1;
result <<= 1; // 左移1位，腾出最低位
result |= n & 1; // 放入n的最低位
```

### >> 右移
操作规则	所有位右移 n 位，左边补符号位（正数补 0，负数补 1）
#### 基础性质	
1. 正数右移：n >> k = Math.floor (n / 2^k)；
2. 负数右移保持符号不变

#### 常见技巧
1. 逐位遍历二进制位（统计 1 的个数基础版）：
```js
function countOneBasic(n) {
    let count = 0;
    for (let i=0; i<32; i++) {
        count += n & 1; // 提取最低位
        n >>= 1; // 右移，次低位变最低位
    }
    return count;
}
console.log(countOneBasic(11)); // 3
```

## 有符号和无符号

### 左移
1. 左移（<<）：低位补 0，可能导致溢出（符号位被修改）
规则：所有位左移 n 位，低位补 0，高位溢出直接丢弃；
对有符号数的影响：
正数左移：无溢出时等价于 ×2ⁿ，溢出则符号位变 1，正数变负数；
负数左移：无溢出时保持负数，溢出则符号位变 0，负数变正数。
```js
// 示例1：正数左移溢出（8位视角，32位同理）
let a = 127; // 8位：01111111（最大正有符号数）
console.log(a << 1); // 254 → 8位溢出后：11111110（解读为-2）

// 示例2：32位有符号数左移
let b = 2147483647; // 32位最大正数：01111111 11111111 11111111 11111111
console.log(b << 1); // -2（符号位被置1，变成负数）
```

### 右移
1. 右移（>>）：补符号位，保证符号不变（但除法是向下取整）
规则：所有位右移 n 位，高位补符号位（正数补 0，负数补 1）；
对有符号数的影响：
正数右移：等价于 Math.floor (n / 2ⁿ)，和无符号数一致；
负数右移：仍保持负数，但结果是 向下取整（而非简单除以 2），容易和预期不符。
```js
// 示例1：正数右移（符合预期）
console.log(11 >> 1); // 5（11/2=5.5 → 向下取整5）

// 示例2：负数右移（易踩坑）
console.log(-5 >> 1); // -3（而非-2）
// 原因：-5的32位补码是11111111...11111011，右移1位后是11111111...11111101（补码）→ 解读为-3
```

2. 按位取反（~）：符号位翻转，结果必为 “-n-1”
规则：所有位取反（0→1，1→0），包括符号位；
对有符号数的影响：补码特性导致~n = -n - 1，正数取反变负数，负数取反变正数。
```js
// 示例1：正数取反
console.log(~5); // -6（5的补码00000101 → 取反11111010 → 补码解读为-6）

// 示例2：负数取反
console.log(~-5); // 4（-5的补码11111011 → 取反00000100 → 解读为4）

// 核心规律：~n + 1 = -n（快速求相反数）
console.log(~5 + 1); // -5
console.log(~-5 + 1); // 5
```

### 其他情况
1. 负数参与位运算的结果解读
有符号数的位运算结果，若最高位为 1，会按补码解读为负数
```js
// 示例：-1的位运算（补码全1）
console.log(-1 & 1); // 1（最低位为1）
console.log(-1 | 2); // -1（全1 | 00000010 = 全1 → 解读为-1）
console.log(-1 ^ 3); // -4（全1 ^ 00000011 = 11111100 → 补码解读为-4）
```
### 总结
核心根源：有符号数的补码存储规则（最高位为符号位）是所有影响的本质；关键影响点：
1. 位移运算：左移可能溢出（符号位改变），右移（>>）补符号位（负数除法向下取整），>>> 会把负数转正数；
2. 按位取反：必满足~n = -n -1，符号位翻转导致正负互换；
3. &/|/^：操作本身无区别，仅结果解读受符号位影响；
4. 实践建议：处理有符号数的位运算时，优先关注符号位是否被修改，负数右移 / 取反的结果需结合补码规则验证。